library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.spect_pkg.all;
use std.textio.all;

entity tb_mag_sqr_fft is end;
architecture sim of tb_mag_sqr_fft is
    -- 定义二进制文件类型
    type binary_file is file of character;
    
    -- DUT 端口信号
    signal clk   : std_logic := '0';
    signal rst_n : std_logic := '0';
    signal start : std_logic := '0';
    signal done  : std_logic;
    signal addr  : addr_t;
    signal din   : signed(DATA_WIDTH-1 downto 0);
    signal dout  : signed(DATA_WIDTH-1 downto 0);
    signal we    : std_logic;

    -- RAM 接口信号
    signal ram_addr : addr_t;
    signal ram_din  : signed(DATA_WIDTH-1 downto 0);
    signal ram_dout : signed(DATA_WIDTH-1 downto 0);
    signal ram_we   : std_logic;

    constant CLKPER : time := 20 ns;

begin
    clk <= not clk after CLKPER/2;

    ------------------------------------------------------------------
    -- 实例化 DUT
    dut: entity work.mag_sqr_fft
        port map (
            clk      => clk,
            rst_n    => rst_n,
            start    => start,
            done     => done,
            ram_addr => addr,
            ram_din  => din,
            ram_dout => dout,
            ram_we   => we
        );

    ------------------------------------------------------------------
    -- 实例化 RAM
    ram_inst: entity work.ram_sp
        port map (
            clk  => clk,
            addr => ram_addr,
            din  => ram_din,
            we   => ram_we,
            dout => ram_dout
        );

    -- 连接 RAM 信号
    ram_addr <= addr;  -- DUT 地址直接连接到 RAM
    ram_din  <= dout;  -- DUT 输出直接连接到 RAM 输入
    ram_we   <= we;    -- DUT 写使能直接连接到 RAM
    din      <= ram_dout; -- RAM 输出直接连接到 DUT 输入

    ------------------------------------------------------------------
    -- 测试流程控制
    stim: process
        -- 从二进制文件读取signed值 (使用impure)
        impure function read_signed_from_file(file f : binary_file) return signed is
            variable char1, char2 : character;
            variable byte1, byte2 : integer;
            variable result      : signed(15 downto 0);
        begin
            read(f, char1);
            read(f, char2);
            byte1 := character'pos(char1);
            byte2 := character'pos(char2);
            result(7 downto 0) := to_signed(byte1, 8);
            result(15 downto 8) := to_signed(byte2, 8);
            return result;
        end function;

        -- RAM 写入过程
        procedure ram_write(addr_i : natural; data : signed) is
        begin
            ram_addr <= to_unsigned(addr_i, ADDR_WIDTH);
            ram_din  <= data;
            ram_we   <= '1';
            wait until rising_edge(clk);
            ram_we   <= '0';
            wait until rising_edge(clk);  -- 额外周期确保稳定
        end procedure;

        -- RAM 读取过程 (返回读取的值)
        impure function ram_read(addr_i : natural) return signed is
            variable data : signed(DATA_WIDTH-1 downto 0);
        begin
            ram_addr <= to_unsigned(addr_i, ADDR_WIDTH);
            ram_we   <= '0';
            wait until rising_edge(clk);
            data := ram_dout;  -- 直接赋值给变量
            wait until rising_edge(clk);  -- 额外周期确保稳定
            return data;
        end function;

        procedure load_vector(file_name : string) is
            file f     : binary_file;
            variable status : file_open_status;
            variable buf   : signed(15 downto 0);
            variable idx   : integer := 0;
        begin
            file_open(status, f, file_name, read_mode);
            assert status = open_ok
                report "Failed to open file: " & file_name
                severity failure;
                
            while not endfile(f) loop
                buf := read_signed_from_file(f);
                ram_write(idx, buf);  -- 使用 RAM 写入过程
                idx := idx + 1;
            end loop;
            file_close(f);
        end procedure;

        procedure compare_result(file_name : string) is
            file f     : binary_file;
            variable status : file_open_status;
            variable buf   : signed(15 downto 0);
            variable idx   : integer := 0;
            variable ram_val : signed(15 downto 0);
        begin
            file_open(status, f, file_name, read_mode);
            assert status = open_ok
                report "Failed to open file: " & file_name
                severity failure;
                
            while not endfile(f) loop
                buf := read_signed_from_file(f);
                ram_val := ram_read(idx * 2);  -- 使用 RAM 读取函数
                assert ram_val = buf
                    report "Mismatch @ " & integer'image(idx) & 
                           ": Expected " & integer'image(to_integer(buf)) & 
                           ", got " & integer'image(to_integer(ram_val))
                    severity error;
                idx := idx + 1;
            end loop;
            file_close(f);
        end procedure;

    begin
        -- 初始化
        ram_we <= '0';
        wait for 1*CLKPER;
        rst_n <= '1';

        -- === 三组向量循环 ===
        for vec in 0 to 2 loop
            case vec is               -- 文件名切换
                when 0 => load_vector("stim/impulse_in.bin");
                when 1 => load_vector("stim/tone1_in.bin");
                when others => load_vector("stim/random_in.bin");
            end case;

            start <= '1'; 
            wait until rising_edge(clk);
            start <= '0';

            wait until done = '1';
            wait until rising_edge(clk);  -- 给 DONE 状态一个周期

            -- 结果对比
            case vec is
                when 0 => compare_result("stim/impulse_gold.bin");
                when 1 => compare_result("stim/tone1_gold.bin");
                when others => compare_result("stim/random_gold.bin");
            end case;

            report "Vector " & integer'image(vec) & " PASS";
        end loop;

        report "All tests passed!" severity note;
        wait;
    end process;
end architecture;